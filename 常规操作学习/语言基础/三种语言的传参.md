在阅读某代码的时候，对三种语言的传参形式突然有些兴趣，这边准备实践，并且具体分析一波。

首先抛出一个非常有趣的JAVA函数：来源于<码出高效>

```java
public class ParamPassing {
	private static StringBuilder strBuild = 
			new StringBuilder("old_stringBuilder");
	public static void main(String[] arg) {
		// 这里使用相同的参数 当然这里都是引用传递
		method(strBuild,strBuild);
		System.out.println(strBuild);
	}
	public static void method(StringBuilder str1,StringBuilder str2) {
		str1.append(".metod.first_");
		str2.append("method.second");
		
		str1 = new StringBuilder("new stringBuilder");
		str1.append("new method`s append");
	}
}
```

这里第6行，将一个引用调用的东西，同时传递给同一个函数，做不同的处理，会发生什么？

首先直接公布结果

`old_stringBuilder.metod.first_method.second`

首先来看JAVA：

1. JAVA

   > https://www.zhihu.com/question/31203609

   JAVA分为基本类型和引用类型。

   比如`int`就是属于基本类型，而`String`就是属于引用类型。基本类型赋值会覆盖掉原来的值，而引用类型不会。引用会改变其引用锁指向的地址，原来引用的东西，就等着垃圾回收器(GC),去回收啦~

   而JAVA的**参数传递基本上就是赋值操作**。

   答者[Intopass](https://www.zhihu.com/people/intopass)，在这个上面讲的很好。这里就不再赘述啦。

   那么问题来了，JAVA的基本类型有啥子：

   > https://www.cnblogs.com/doit8791/archive/2012/05/25/2517448.html

   > **字符类型**char、**布尔类型**boolean、**数值类型**byte、short、int、long、float、double。
   >
   > 数值类型又可以分为整数类型byte、short、int、long和浮点数类型float、double。
   >
   > 当然还有一个例外(占位？)，void。` java.lang.Void`

   当然，这里也体现出Java非常平易近人的一点，这些玩意的取值范围都是固定哒！不随机器变化！<!--（c++对此踩了一脚）-->

   以及还有更为平易近人的一点，他有个叫做封装器类，比如byte对应Byte，取值范围还写到了封装器来，`Byte.SIZE`,`Byte.MIN_VALUE`...<!--(C嘎嘎程序员表示不服)-->

   然后就是引用类型（对象类型）

   > 类 接口 数组 枚举 标注

   其实现与JVM的内存分配有关，

   简单划分有三类：

   1. .Heap：堆空间
   2. .Stack：栈空间
   3. .Code：代码区

   > https://blog.csdn.net/CSDN_Terence/article/details/77771429

   这个文章就描述了JAVA调优的理由，可以通过优化GC，增加垃圾回收的能力。以增加JAVA的性能。

2. 然后就是python

   > https://www.zhihu.com/question/20591688

   python划分类两类，一类是可变对象，一类是不可变对象。

   1. **对于不可变对象作为函数参数，相当于C系语言的值传递；**

      int,string,float,tuple

   2. **对于可变对象作为函数参数，相当于C系语言的引用传递。**

      dict,list

   感觉和上面的JAVA很像诶。就不能叫一个名字？

   但是呢，却不能把python简单的与JAVA的实现做等号。

   > https://www.zhihu.com/question/20591688/answer/465437171

   ```python
   x = 1
   y = x
   print(y is x) #True 注意此处的is用来比较 y 与 x 所指向的对象是否为同一个，也就是id(x)与id(y)是不是一样的
   # id方法返回的是某对象的id号（一个int值），在其生命周期内保证唯一和不变, id(x)就是返回x所指向的对象的id
   y = 2
   print(y is x) # False
   x += 1 # 此时x的值为2,  x绑定到了对象 int2 上,同时id(x)也会发生改变 
   print(y is x) # True
   ```

   这里有一段很有代表性的迷之代码。

   x=1是，把对象int 1，绑定(binging)给了一个名字(name)，所以可以用x来引用这个对象，而x=y，表示y现在也是int 1的一个名字啦！所以，他两都是同一个对象。其中最为奇妙的一点就是，一个通过+1，一个通过=2，这两个会表示为相同。

   ```python
   x = [1,2,3]
   print(id(x)) # 2289361143944
   x.append(4)
   print(id(x)) # 2289361143944
   x = [1,2,3,4]
   print(id(x)) # 2289363934664
   ```

   另外一个代码，这里让`[1,2,3]`绑定给了x，增加也不变，但如果重新命名就不一样了。

   然后我们再回到这个代码中。

   ```python
   def function(arr1,arr2):
       arr1.append(".metod.first_") #3957320
       arr2.append("method.second") #3957320 
   
       str1 = ["new array"]	#3957384
       str1.append("213213")	#3957384
   
   arr = ["old_arrayr"] # 3957320
   function(arr,arr)
   print(arr)
   ```

   答案相同，但我们来print下他们的id。

   这样答案就有了，python维护了一个不可变变量的一个表。比如

   ```
   print(id(1))	#8790996145184	#8791013577760
   print(id(2))	#8790996145216	#8791013577792
   ```

   就会发现，永远相差32.。emm，有趣。并且不知道为啥，我的这个只有这两组。。emm？

   > https://draapho.github.io/2016/11/21/1618-python-variable/
   >
   > https://my.oschina.net/leejun2005/blog/145911 from
   >
   > Python 没有「变量」，我们平时所说的变量其实只是「标签」，是引用。。。用C++的话来说，就是指针。

   在上面这个链接中，有个很有意思的点：

   ```python
   In[2]: def foo(a, b, c=[]):
   ...        c.append(a)
   ...        c.append(b)
   ...        print(c)
   ...
   In[3]: foo(1, 1)
   [1, 1]
   In[4]: foo(1, 1)
   [1, 1, 1, 1]
   In[5]: foo(1, 1)
   [1, 1, 1, 1, 1, 1]
   ```

   这里告诫我们，不要使用可变参数作为默认值。因为python并不会为可变参数新建一个对象。

   应该这么写。

   ```
   def foo(a, b, c=None):
       if c is None:
           c = []
   ```

3. 最后是我们亲爱的，敬爱的崇敬的c++

   但今天有点晚了，明天再说，也可能就没有然后了，谁知道呢！哈哈哈，就是这么歧视你！

4. 可能存在的ruby？

   都快忘光了。。。只记得p和put用起来很爽。