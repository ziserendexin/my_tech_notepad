#### 中文文档的学习

> https://www.kubernetes.org.cn/k8s

1. k8s的目标

   Kubernetes一个核心的特点就是能够自主的管理容器来保证云平台中的容器按照用户的期望状态运行着。

   现在Kubernetes着重于不间断的服务状态（比如web服务器或者缓存服务器）和原生云平台应用（Nosql）,在不久的将来会支持各种生产云平台中的各种服务，例如，分批，工作流，以及传统数据库。

2. Kubernetes-核心资源之Pod

   1. 概述

      https://www.kubernetes.org.cn/3965.html

      首先，其包括了dock-compose的功能，包括容器网络交互的定义等信息。

      并且还额外的增加了更详细的状态检测机制（liveness和readiness，可以通过tcp、http来检测是否正常）、镜像拉取策略、其他pod重启策略、资源限制策略(包括异常了怎么重启)

   2. 目标

      pod的目标是协助k8s保证某服务，一直启动。

3. 网络

   Kubernetes支持一种特殊的网络模型，Kubernetes创建了一个地址空间，并且不动态的分配端口，它可以允许用户选择任何想使用的端口，为了实现这个功能，它为每个Pod分配IP地址。

4. 构架

   ![architecture](F:\GitHub\my_tech_notepad\k8s学习\jpg\architecture.png)

   Kubernetes主要由以下几个核心组件组成：

   - etcd保存了整个集群的状态；
   - apiserver提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；
   - controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；
   - scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；
   - kubelet负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理；
   - Container runtime负责镜像管理以及Pod和容器的真正运行（CRI）；
   - kube-proxy负责为Service提供cluster内部的服务发现和负载均衡；

   除了核心组件，还有一些推荐的Add-ons：

   - kube-dns负责为整个集群提供DNS服务
   - Ingress Controller为服务提供外网入口
   - Heapster提供资源监控
   - Dashboard提供GUI
   - Federation提供跨可用区的集群
   - Fluentd-elasticsearch提供集群日志采集、存储与查询

5. API设计原则

   1. **所有API应该是声明式的**。

      正如前文所说，声明式的操作，相对于命令式操作，对于重复操作的效果是稳定的，这对于容易出现数据丢失或重复的分布式环境来说是很重要的。另外，声明式操作更容易被用户使用，可以使系统向用户隐藏实现的细节，隐藏实现的细节的同时，也就保留了系统未来持续优化的可能性。此外，声明式的API，同时隐含了所有的API对象都是名词性质的，例如Service、Volume这些API都是名词，这些名词描述了用户所期望得到的一个目标分布式对象。

   2. **API对象是彼此互补而且可组合的**。

   3. **高层API以操作意图为基础设计**。

   4. **低层API根据高层API的控制需要设计**。

   5. **尽量避免简单封装，不要有在外部API无法显式知道的内部隐藏的机制**。

   6. **API操作复杂度与对象数量成正比**。

   7. **API对象状态不能依赖于网络连接状态**。

   8. **尽量避免让操作机制依赖于全局状态，因为在分布式系统中要保证全局状态的同步是非常困难的**。

6. 实验

   依然是在centos7的虚拟机上搞搞事。试试这个minikube。



   > 官方文档：https://kubernetes.io/docs/setup/minikube/
   >
   > 中文文档：https://linux.cn/article-8847-1.html
   >
   >

   1. 安装

      对于 Linux，安装 [VirtualBox](https://www.virtualbox.org/wiki/Downloads) 或者 [KVM](http://www.linux-kvm.org/)，然后再安装 Kubectl 和 Minkube。

      > KVM：使用KVM，可以运行多个运行未修改的Linux或Windows映像的虚拟机。每个虚拟机都有专用的虚拟化硬件：网卡，磁盘，图形适配器等。

      > VirtualBox 是一款开源虚拟机软件。使用者可以在VirtualBox上安装并且执行Solaris、Windows、DOS、Linux、[OS/2](https://www.baidu.com/s?wd=OS%2F2&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao) Warp、BSD等系统作为客户端[操作系统](https://www.baidu.com/s?wd=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)。

      两者选择：因此使用KVM，并且他也是开源的

      > https://blog.csdn.net/wj_j2ee/article/details/7847836
      >
      > vbox 是由 qemu 改写而成，包含大量 qemu 代码。可以使用于 不支持 虚拟化的cpu。值得说的一点：vbox 在图形方面比较好，能进行2D 3D加速。cpu控制不理想（估计是因为图形支持的缘故）。操作上有独立的图形界面，易于上手。
      > kvm 是linux内核包含的东西，使用qemu作为上层管理（命令行）。cpu 必须支持虚拟化。性能，作为服务器很好，可是图形能力十分的差。即使放电影，图像也是像刷油漆一样，一层一层的。cpu使用率控制很好。 控制上比较简洁，功能比较丰富：比如使用 “无敌功能”所有更改指向内存，你的镜像永远保持干净。 “母镜像”功能让你拥有n个独立快照点。 还有很多参数。另外，kvm作为内核级的虚拟机，刚开始发展关注的公司比较多——但是还没有达到商业应用的水平。
      >
      > 总体而言：在支持 虚拟化的情况下，vbox 和 kvm 的性能差不多，主要是面向对象不同：kvm使用于服务器，vbox使用于桌面应用。

   2. 