1. #### 概述

   docker强大的地方在于，其屏蔽了一部分网络的问题。（从集群的角度来看，屏蔽了更多的网络设置。）可以使用端口的自定义暴露，避免诸多端口占用、冲突而导致的无法连接的问题。

   **这个网站上非常详细地说明了docker的网站配置。建议通读。**

   > http://success.docker.com/article/networking

   docker设计本身就面临着网络容器和微服务的挑战。

   以下主题是容器化应用程序的常见设计主题： 

   - **可移植性**
     - *如何在利用独特网络特性的同时保证跨多种网络环境的最大可移植性？*
   - **服务发现**
     - *我如何知道服务在扩展和减少时的是否还活着？*
   - **负载均衡**
     - *当服务本身被提升和扩展时，如何跨服务共享负载？*
   - **安全**
     - *如何分段以防止错误的容器相互访问？*
     - *如何保证具有应用程序和群集控制流量的容器是安全的？*
   - **性能**
     - *如何在最小化延迟和最大化带宽的同时提供高级网络服务？*
   - **可扩展性**
     - *在跨多个主机扩展应用程序时，如何确保不会牺牲这些特性？*

2. #### 容器网络模型

   Docker网络架构构建在一组称为*容器网络模型*（CNM）的接口上。CNM的理念是为各种基础设施提供应用程序可移植性。该模型在实现应用程序可移植性方面取得了平衡，并且还利用了基础结构的特殊功能。 

   ![cnm](.\network_jpg\cnm.png)

   ### CNM构造

   CNM中有几个高级构造。它们都是操作系统和基础架构无关的，因此无论基础架构堆栈如何，应用程序都可以获得统一的体验。

   - **沙箱** - 沙箱包含容器网络堆栈的配置。这包括管理容器的接口，路由表和DNS设置。Sandbox的实现可以是Linux网络命名空间，FreeBSD Jail或其他类似的概念。沙箱可能包含来自多个网络的许多端点。
   - **端点** - 端点将沙箱连接到网络。Endpoint构造存在，因此可以从应用程序中抽象出与网络的实际连接。这有助于保持可移植性，以便服务可以使用不同类型的网络驱动程序，而无需关心它如何连接到该网络。
   - **网络** - CNM未根据OSI模型指定网络。网络的实现可以是Linux网桥，VLAN等。网络是端点的集合，它们之间具有连接。未连接到网络的端点在网络上没有连接。

3. ####  docker的网络模式

   Docker本机网络驱动程序是Docker Engine的一部分，不需要任何额外的模块。它们通过标准`docker network`命令调用和使用。存在以下本机网络驱动程序。 

   | Driver      | Description                                                  |
   | ----------- | ------------------------------------------------------------ |
   | **Host**    | 使用`host`驱动程序，容器使用主机的网络堆栈。没有名称空间分隔，主机上的所有接口都可以由容器直接使用 |
   | **Bridge**  | 该`bridge`驱动程序创建一个由码头工人管理主机上的Linux的桥梁。默认情况下，网桥上的容器可以相互通信。也可以通过`bridge`驱动程序配置对容器的外部访问 |
   | **Overlay** | 该`overlay`驱动程序创建一个支持多主机网络开箱即用的覆盖网络。它结合使用本地Linux网桥和VXLAN，通过物理网络基础设施覆盖容器到容器的通信 |
   | **MACVLAN** | `macvlan`驱动程序使用MACVLAN桥接模式来建立容器的接口和一个亲本宿主接口（或子接口）之间的连接。它可用于为可在物理网络上路由的容器提供IP地址。此外，可以将VLAN中继到`macvlan`驱动程序以强制执行第2层容器分段 |
   | **None**    | 该`none`驱动程序提供了一个容器，它自己的网络堆栈和网络命名空间，但不将容器内的接口。如果没有其他配置，容器将与主机网络堆栈完全隔离 |

   可以使用`docker network ls`命令查看当前已有的网络。帮助理解。

4. ####  远程网络驱动程序

   参考使用：[**contiv**](http://contiv.github.io/) 、[**weave**](https://www.weave.works/docs/net/latest/introducing-weave/) 、[**calico**](https://www.projectcalico.org/) 、[**kuryr**](https://github.com/openstack/kuryr) 。

5. ####  远程IPAM驱动程序

   [**infoblox**](https://hub.docker.com/r/infoblox/ipam-driver/) 

6. #### Bridge方式

   #### ![](.\network_jpg\bridge-driver.png)

   - `docker0` 是Linux桥的名称，它是用于实现此网络的内核构建块

     ```
     host $ brctl show
     bridge name      bridge id            STP enabled    interfaces
     docker0          8000.0242504b5200    no             vethb64e8b8
     ```

   - 一个主机上的工具：brctl，显示了主机现存网络namespace的Linux桥接。它显示了一个叫做`docker0` 的单桥，`docker0`有一个接口，`vetha3788c4`，它提供从桥到`eth0`容器内接口`c1`的连接。 

   通俗点来说，docker本身创建了一个`docker0`的默认bridge，并建立对应的`veth`的接口，将其连接到容器内部网络。

   如果存在用户自定义网络，则会创建一个`br-容器网络名`的bridge，并创建对应的veth，连接到容器内部。

   ```
   [root@ zhy]# brctl show
   bridge name	bridge id		STP enabled	interfaces
   br-96c9af1e6120		8000.0242d357bfbb	no		veth0cac912
   docker0		8000.024259f87951	no		
   virbr0		8000.5254006c5e8c	yes		virbr0-nic
   ```

   ![](.\network_jpg\bridge2.png)

7. #### 关于host、overlay、User-Defined Bridge、macvlan，暂且略过

   原文中这句话需要注意：

   Docker Swarm控制平面可自动完成覆盖网络的所有配置。不需要VXLAN配置或Linux网络配置。 

   数据平面加密是覆盖的可选功能，也可以在创建网络时由覆盖驱动程序自动配置。用户或网络运营商只需定义网络（`docker network create -d overlay ...`）并将容器附加到该网络。 

8. #### compose的网络原理

   例如，假设您的应用程序位于名为的目录中`myapp`，您的`docker-compose.yml`样子如下所示：

   ```
   version: "3"
   services:
     web:
       build: .
       ports:
         - "8000:8000"
     db:
       image: postgres
       ports:
         - "8001:5432"
   ```

   运行时`docker-compose up`，会发生以下情况：

   1. 创建了一个名为`myapp_default`的网络。
   2. 使用`web`配置创建容器。它`myapp_default`以名义加入网络 `web`。
   3. 使用`db`配置创建容器。它`myapp_default`以名义加入网络 `db`。

9. #### compose下推荐的网络设定

   适用于v2以上，v1(说的就是centos6)不支持。

   ```
   version: "3"
   services:
   
     proxy:
       build: ./proxy
       networks:
         - frontend
         - default_network
     app:
       build: ./app
       networks:
         - frontend
         - backend
     db:
       image: postgres
       networks:
         - backend: 
         	aliases: 
         		- postgres	# 设置别名
         - default_network
   
   networks:
     frontend:
       # 使用一个现有网络
       driver: custom-driver-1
     backend:
       # 使用一个现有网络并设置一些乱七八糟的东西
       driver: custom-driver-2
       driver_opts:
         foo: "abcd"
         bar: "efgh"
     default_network: # 活着干脆什么都不做，使用其自定义的网络。
   ```

   推荐使用如上所示的网络配置方式。

   对于compose内部(语言层)，使用可读化名称：frontend、backend，来标记网络间的关系。同时把网络的详细设置(包括加入已有网络，以及新建网络、驱动方式)，全部写到network下（实现层）。

10. #### 自定义网络名

    在3.5+，网络可以完全实用其自定义名称。

    ```
    version: "3.5"
    networks:
      frontend:
        name: custom_frontend
        driver: custom-driver-1
    ```

11. #### 加入已有网络

    如果您希望容器加入预先存在的网络，请使用以下[`external`选项](https://docs.docker.com/compose/compose-file/compose-file-v2/#network-configuration-reference)：

    ```
    networks:
      default:
        external:
          name: my-pre-existing-network
    ```

    而不是尝试创建一个名为的网络`[projectname]_default`，Compose会查找一个名为的网络`my-pre-existing-network`，并将应用程序的容器连接到它。

    但如果这么做，也需要第10步中，强行设定网络名。（说的就是你，数据库，redis网络。）

    详情参见：

    https://docs.docker.com/compose/compose-file/compose-file-v2/#external-1

12. #### 为何不使用links

    1. links后，其网络名是临时生成的，这也意味着，很难将新建容器，加入到已有容器中。
    2. links会让docker-compese产生依赖项的副作用，但实际上，应该使用更为明确的`depends_on`选项来搞定依赖。
    3. links完全不受swarm支持，并且会对swarm化产生巨大的阻碍。
    4. 关于别名`aliases`，network依然支持。并不会影响具体的操作.

13. ####  `aliases`

    直接copy了：

    网络上此服务的别名（备用主机名）。同一网络上的其他容器可以使用服务名称或此别名连接到其中一个服务的容器。

    由于`aliases`是网络范围的，因此相同的服务可以在不同的网络上具有不同的别名。

    > **注意**：网络范围的别名可以由多个容器共享，甚至可以由多个服务共享。如果是，则无法保证名称解析为的容器。

    一般格式如下所示。

    ```
    services:
      some-service:
        networks:
          some-network:
            aliases:
             - alias1
             - alias3
          other-network:
            aliases:
             - alias2
    ```

    在下面的例子中，提供了三种服务（`web`，`worker`，和`db`），其中两个网络（沿`new`和`legacy`）。该`db`服务是在到达的主机名`db`或`database`上`new`网络，并`db`或`mysql`将上`legacy`网络。

    ```
    version: '2'
    
    services:
      web:
        build: ./web
        networks:
          - new
    
      worker:
        build: ./worker
        networks:
          - legacy
    
      db:
        image: mysql
        networks:
          new:
            aliases:
              - database
          legacy:
            aliases:
              - mysql
    
    networks:
      new:
      legacy:
    ```

    PS：当然，你也可以使用ip地址的方式，但。。。额,但这种会好麻烦啊。